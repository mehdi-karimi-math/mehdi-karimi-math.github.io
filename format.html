
<!DOCTYPE html>
<html>


<head>
<link rel="stylesheet" href="style.css?ver=<?php echo rand(111,999)?>">
</head>

<body  style="background-color:white " >

<head>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<header>
<h1>DDS Users' Guide</h1>
</header>

<nav>
<font color="red"> Creators: </font> <br>
&ensp; <a href="index.html"> Mehdi Karimi </a> <br>
&ensp; <a href="http://www.math.uwaterloo.ca/~ltuncel/"> Levent Tuncel
</a> <br>
<br> <br>
&ensp; <a href="DDS.html"> Main page </a> 
</nav>


<div style="position: absolute;
  top: 100px;
  left: 220px ">


<section>
<h2> How to use DDS </h2> 
<p>
<!In practice, we typically have \(D=\bar D -b\), where \(\text{int} \bar D\) is the domain of a "canonical" s.c. 
barrier and \(b \in R^m\). For example, for LP, we typically have \(D=R^n_++b\), where \(b \in R^m\) is 
given as part of the input data, and \(-\sum_{i=1}^{n}\ln(x_i)\) is a s.c. barrier for \(R^n_+\). >
After installation, the command in Matlab that calls DDS is <br><br>


[x,y,info]=DDS(c,A,b,cons,OPTIONS);

<br>
<br>

<b> Input Arguments: </b> <br>
<b> cons: </b> A cell array that contains the information about the type of
constraints. <br>
<b> \(c,A,b\): </b> Input data for DDS: \(A\) is the coefficient matrix, \(c\)
is the objective vector, \(b\) is the RHS vector (i.e., the shift in
the definition of the convex domain \(D\)). <br>
<b> OPTIONS: </b> (optional): An array which contains information about the
tolerance  or initial points.  <br> <br>

<b> Output Arguments: </b> <br>
\(x\): Primal point. <br>
\(y\): Dual point which is a cell array. Each cell contains the dual solution for the constraints in the corresponding cell  in \(A\). <br>
<b> info </b>: a structure array containing performance information
such as <b> info.time </b> , which returns the CPU time for solving the
problem. <br> <br>

The following table shows the classes of function/set constraints the current version of
DDS accepts, plus the abbreviation we use to represent the
constraint.
 We assume that the objective function is "\(\inf \ \langle
c,x\rangle\)". Note that <b>A</b>, <b>b</b>, and <b>cons</b> are cell
arrays in Matlab; to see how to define them for a combination of constraints, you can check the users' guide. <b>cons{k,1}</b> represents type of the \(k\)th
block of constraints by using the abbreviations of the following table.
We can input several blocks of set constraints into
DDS and the type of each block is given in <b>cons{k,1}</b>. For example, if the \(k\)th block is an SDP constraint, then
<b> cons{k,1}='SDP'</b>. 

<table style="width:70%">
<caption>Function/set constraints the current version of DDS accepts, and their abbreviations. </caption>
<tr> <th>  function/set constraint  </th>  <th> abbreviation </th> </tr>
<tr>  <td> LP </td>   <td>  LP </td> </tr>
<tr>  <td> SOCP </td>  <td>  SOCP </td>  </tr>
<tr>  <td> rotated SOCP </td>  <td>  SOCPR </td>  </tr>
<tr> <td> SDP </td> <td>  SDP </td>   </tr>
<tr> <td> Generalized Power Cone </td> <td>  GPC </td>   </tr>
<tr> <td> Quadratic Constraints </td>  <td>  QC </td>  </tr>
<tr>  <td> Epigraph of a matrix norm  </td>  <td> MN </td> </tr>
<tr> <td> Direct sum of 2-dimensional sets </td> <td>  TD </td>   </tr>
<tr>  <td> Quantum Entropy </td> <td>  QE </td>   </tr>
<tr>  <td> Quantum Relative Entropy </td> <td>  QRE </td>   </tr>
<tr>  <td> Relative Entropy </td> <td>  RE </td>   </tr>
<tr>  <td> Hyperbolic Polynomials </td> <td>  HB </td>   </tr>
<tr>  <td> Equality Constraints </td> <td>  EQ </td>   </tr>
</table>

<!--


Different classes of inequalities (set functions) can be added to the
code. The command in Matlab that calls the DDS code is
\([x,y]=DDS(c,A,b,Z)\), where \(A\) is
the coefficient matrix, \(c\) is the objective vector,\(b\) is the RHS
vector, and \(Z\) is an structure variable that contains the
information about the type of constraints. The important note is that
different classes of constraints must follow an order. he following
table gives the order of the classes that are currently accepted by
the DDS code. For example, if we want to input an SDP
inequality and then some inequalities constructed by the direct sum of
2-dimensional sets (such as geometric programming constraints), in
forming \((c,A,b)\),
the data for the SDP comes first.

<table style="width:70%">
<caption>Order of the inputs for different constraint types.  </caption>
<tr> <th>  Order  </th>  <th>  type of constraint </th> </tr>
<tr> <td>  (1) </td>  <td> LP </td>  </tr>
<tr> <td>  (2) </td>  <td> SOCP </td>  </tr>
<tr> <td>  (3) </td>  <td> SDP </td>  </tr>
<tr> <td>  (4) </td>  <td> QCQP </td>  </tr>
<tr> <td>  (5) </td>  <td> Epigraph of a matrix norm  </td>  </tr>
<tr> <td>  (6) </td>  <td> Direct sum of 2-dimensional sets </td>  </tr>
<tr> <td>  (7) </td>  <td> Quantum Entropy </td>  </tr>

</table>

--> 
</p>
  

</section>

</div>

</body>
</html>